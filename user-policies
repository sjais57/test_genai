@app.post("/user-policies")
async def list_user_policies(request: UserPoliciesRequest):
    start_time = time.time()
    """List all policies applicable to a specific user and their groups"""
    applicable_policies = []
    client_dir = "policies/clients"

    if not os.path.exists(client_dir):
        return {"policies": []}

    for file in os.listdir(client_dir):
        if file.endswith(".rego") and not file.endswith("_test.rego"):
            policy_path = os.path.join(client_dir, file)
            policy_path = policy_path.replace("\\", "/")

            with open(policy_path, 'r') as f:
                policy_content = f.read()

            # Check enabled flag
            enabled_match = re.search(r'policy_enabled\s*:\s*(true|false)', policy_content)
            if enabled_match and enabled_match.group(1) == "false":
                continue

            # Extract allowed models
            allowed_model = []
            pattern = r'allowed_models\s*=\s*\[(.*?)\]'
            match = re.search(pattern, policy_content, re.DOTALL)
            if match:
                models_str = match.group(1)
                allowed_model = [m.strip() for m in re.findall(r'"([^"]+)"', models_str)]

            # Convert to your required structure
            model_names = []
            deploy_models = {}

            for model_path in allowed_model:
                subtree = get_model_subtree(model_yaml_data, model_path)
                if not subtree:
                    continue
                configs = subtree.get("configs", [])
                for cfg in configs:
                    model_names.append(cfg.get("unique_model_name", ""))
                    hpc_model = cfg.get("hpc_model_name", "")
                    if hpc_model:
                        if hpc_model not in deploy_models:
                            deploy_models[hpc_model] = []
                        deploy_models[hpc_model].append(cfg.get("inference_type", ""))

            # Extract user role
            user_role = []
            user_match = re.search(rf'"request.user_id":\s*"(.*?)"', policy_content)
            if user_match:
                # You may want to fetch the label from somewhere else (mapping table)
                user_role.append({
                    "label": "User Role",   # Placeholder label
                    "value": user_match.group(1)
                })

            # Extract group roles
            group_roles = []
            group_role_labels = []
            for group_id in request.group_ids:
                group_match = re.search(rf'"{group_id}":\s*"(.*?)"', policy_content)
                if group_match:
                    role_val = group_match.group(1)
                    group_roles.append(role_val)
                    group_role_labels.append({
                        "label": f"Group {group_id}",
                        "value": group_id
                    })
            # Merge group roles into user_role field (with label/value format)
            user_role.extend(group_role_labels)

            # GPU info (if defined in rego)
            gpu_match = re.search(r'gpu\s*:\s*"(.*?)"', policy_content)
            gpu_val = gpu_match.group(1) if gpu_match else ""

            # Final response structure
            policy_info = {
                "policy_name": os.path.basename(policy_path),
                "user_role": user_role,
                "group_roles": group_roles,
                "gpu": gpu_val,
                "model_name": list(set(filter(None, model_names))),
                "deploy_models": deploy_models
            }

            applicable_policies.append(policy_info)

    end_time = time.time()
    print(f"Total execution time: {end_time - start_time:.3f} seconds")
    return {"policies": applicable_policies}
