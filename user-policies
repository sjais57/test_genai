@app.post("/user-policies")
async def list_user_policies(request: UserPoliciesRequest):
    start_time = time.time()
    """List all policies applicable to a specific user and their groups"""
    applicable_policies = []
    client_dir = "policies/clients"

    if not os.path.exists(client_dir):
        return {"policies": []}

    # Load the model YAML data (assuming this is available globally or needs to be loaded)
    with open("models.yaml", 'r') as f:
        model_yaml_data = yaml.safe_load(f)

    for file in os.listdir(client_dir):
        if file.endswith(".rego") and not file.endswith("_test.rego"):
            policy_path = os.path.join(client_dir, file)
            policy_path = policy_path.replace("\\", "/")

            with open(policy_path, 'r') as f:
                policy_content = f.read()

            # Check if policy is enabled
            enabled_match = re.search(r'policy_enabled\s*:\s*(true|false)', policy_content)
            if enabled_match and enabled_match.group(1) == "false":
                continue

            # Extract lane_access
            lane_access = []
            lane_match = re.search(r'lane_access\s*=\s*\[(.*?)\]', policy_content, re.DOTALL)
            if lane_match:
                lane_values = re.findall(r'"([^"]+)"', lane_match.group(1))
                lane_mapping = {
                    "training_pvt": "Training (Non-Public Data)",
                    "training_pub": "Training (Public Data)",
                    "inference_pvt": "Inference (Non-Public Data)",
                    "inference_pub": "Inference (Public Data)"
                }
                for value in lane_values:
                    label = lane_mapping.get(value, value)
                    lane_access.append({"label": label, "value": value})

            # Extract roles for the specific user
            roles = []
            roles_match = re.search(r'roles\s*=\s*\{(.*?)\}', policy_content, re.DOTALL)
            if roles_match:
                roles_content = roles_match.group(1)
                # Look for user's role definition
                user_role_match = re.search(rf'"{request.user_id}"\s*:\s*\[(.*?)\]', roles_content)
                if user_role_match:
                    roles = re.findall(r'"([^"]+)"', user_role_match.group(1))

            # Extract GPU constraints
            gpu = ""
            gpu_match = re.search(r'gpu_constraint\s*:\s*"(.*?)"', policy_content)
            if gpu_match:
                gpu = gpu_match.group(1)

            # Extract allowed models and get their unique_model_name
            ll_models = []
            deploy_models = {}
            
            models_match = re.search(r'allowed_models\s*=\s*\[(.*?)\]', policy_content, re.DOTALL)
            if models_match:
                model_paths = re.findall(r'"([^"]+)"', models_match.group(1))
                
                for model_path in model_paths:
                    # Get the model subtree from YAML data
                    subtree = get_model_subtree(model_yaml_data, model_path)
                    if not subtree:
                        continue
                    
                    configs = subtree.get("configs", [])
                    if configs:
                        # Get unique_model_name from the first config
                        unique_model_name = configs[0].get("unique_model_name", "")
                        if unique_model_name:
                            ll_models.append(unique_model_name)
                        
                        # Extract deploy frameworks for this model
                        frameworks = []
                        for cfg in configs:
                            framework_name = cfg.get("framework", "")
                            if framework_name and framework_name not in frameworks:
                                frameworks.append(framework_name)
                        
                        if frameworks and unique_model_name:
                            deploy_models[unique_model_name] = frameworks

            # Check if user is directly mentioned or in groups
            user_match = re.search(rf'"{request.user_id}":\s*"(.*?)"', policy_content)
            group_matches = any(re.search(rf'"{group_id}":\s*"(.*?)"', policy_content) for group_id in request.group_ids)

            if user_match or group_matches:
                policy_info = {
                    "policy_name": os.path.basename(policy_path),
                    "lane_access": lane_access,
                    "role": roles,
                    "gpu": gpu,
                    "ll_models": ll_models,
                    "deploy_models": deploy_models
                }
                applicable_policies.append(policy_info)

    end_time = time.time()
    print(f"Total execution time: {end_time - start_time:.3f} seconds")
    return {"policies": applicable_policies}
