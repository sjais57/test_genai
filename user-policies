@app.post("/user-policies")
async def list_user_policies(request: UserPoliciesRequest):
    start_time = time.time()
    """List all policies applicable to a specific user and their groups"""
    applicable_policies = []
    client_dir = "policies/clients"

    if not os.path.exists(client_dir):
        return {"policies": []}

    for file in os.listdir(client_dir):
        if file.endswith(".rego") and not file.endswith("_test.rego"):
            policy_path = os.path.join(client_dir, file)
            # Convert Windows path to Unix-style for consistency
            policy_path = policy_path.replace("\\", "/")

            # Read the policy file to extract user and group roles
            with open(policy_path, 'r', encoding="utf-8") as f:
                policy_content = f.read()

            # Check if policy is enabled (if enabled flag exists)
            enabled_match = re.search(r'policy_enabled\s*:\s*(true|false)', policy_content)
            if enabled_match and enabled_match.group(1).lower() == "false":
                continue

            # -------- Lane Access --------
            lane_access = []
            lane_match = re.search(r'lane_access\s*=\s*\[(.*?)\]', policy_content, re.DOTALL)
            if lane_match:
                lane_values = re.findall(r'"([^"]+)"', lane_match.group(1))
                lane_mapping = {
                    "training_pvt": "Training (Non-Public Data)",
                    "training_pub": "Training (Public Data)",
                    "inference_pvt": "Inference (Non-Public Data)",
                    "inference_pub": "Inference (Public Data)"
                }
                for value in lane_values:
                    label = lane_mapping.get(value, value)
                    lane_access.append({"label": label, "value": value})

            # -------- Roles --------
            roles = []
            roles_match = re.search(r'roles\s*=\s*\{(.*?)\}', policy_content, re.DOTALL)
            if roles_match:
                roles_content = roles_match.group(1)
                # Direct user roles
                user_role_match = re.search(rf'"{request.user_id}"\s*:\s*\[(.*?)\]', roles_content)
                if user_role_match:
                    roles.extend(re.findall(r'"([^"]+)"', user_role_match.group(1)))
                # Group roles
                for group_id in request.group_ids:
                    group_role_match = re.search(rf'"{group_id}"\s*:\s*\[(.*?)\]', roles_content)
                    if group_role_match:
                        roles.extend(re.findall(r'"([^"]+)"', group_role_match.group(1)))
            roles = list(set(roles))  # dedupe

            # -------- GPU Constraint --------
            gpu = ""
            gpu_match = re.search(r'gpu_constraint\s*:\s*"(.*?)"', policy_content)
            if gpu_match:
                gpu = gpu_match.group(1)

            # -------- Allowed Models (ll_models + deploy_models) --------
            ll_models = []
            deploy_models = {}

            models_match = re.search(r'allowed_models\s*=\s*\[(.*?)\]', policy_content, re.DOTALL)
            if models_match:
                model_paths = re.findall(r'"([^"]+)"', models_match.group(1))
                for model_path in model_paths:
                    subtree = get_model_subtree(model_yaml_data, model_path)
                    if not subtree:
                        continue
                    configs = subtree.get("configs", [])
                    if configs:
                        unique_model_name = configs[0].get("unique_model_name", "")
                        if unique_model_name and unique_model_name not in ll_models:
                            ll_models.append(unique_model_name)

                        frameworks = {cfg.get("framework", "") for cfg in configs if cfg.get("framework")}
                        if frameworks and unique_model_name:
                            deploy_models[unique_model_name] = list(frameworks)

            # -------- Check if applicable (user or groups) --------
            user_match = re.search(rf'"{request.user_id}":\s*"(.*?)"', policy_content)
            group_matches = any(
                re.search(rf'"{group_id}":\s*"(.*?)"', policy_content) for group_id in request.group_ids
            )

            if user_match or group_matches:
                policy_info = {
                    "policy_name": os.path.basename(policy_path),
                    "lane_access": lane_access,
                    "role": roles,
                    "gpu": gpu,
                    "ll_models": ll_models,
                    "deploy_models": deploy_models
                }
                applicable_policies.append(policy_info)

    end_time = time.time()
    print(f"Total execution time: {end_time - start_time:.3f} seconds")
    return {"policies": applicable_policies}
