import os
import re
from datetime import timedelta, datetime
from flask import Flask, jsonify, request, make_response, render_template, send_from_directory
from flask_jwt_extended import (
    JWTManager, create_access_token, create_refresh_token,
    jwt_required, get_jwt_identity, decode_token, get_jwt
)
from dotenv import load_dotenv
import logging
import pathlib
import yaml
import uuid
import glob
from flask_swagger_ui import get_swaggerui_blueprint
from swagger_config import get_swagger_dict, get_swagger_json, get_swagger_yaml

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv()

# Import authentication methods
from auth.file_auth import authenticate_file
from auth.ldap_auth import authenticate_ldap, LDAP_AVAILABLE
from utils.api_key import get_additional_claims, BASE_API_KEY_FILE

# GES Integration
try:
    from ges_entitylements.security import EntitlementsService
    GES_AVAILABLE = True
    logger.info("GES integration available")
except ImportError:
    GES_AVAILABLE = False
    logger.warning("GES integration not available - install ges_entitylements package")

# Ensure the templates directory exists
templates_dir = pathlib.Path(__file__).parent / 'templates'
templates_dir.mkdir(exist_ok=True)

# Initialize Flask app
app = Flask(__name__, template_folder=str(templates_dir))

# Configure Swagger UI
SWAGGER_URL = '/dspai-docs'
API_URL = '/swagger.json'

swaggerui_blueprint = get_swaggerui_blueprint(
    SWAGGER_URL,
    API_URL,
    config={
        'app_name': "JWT Auth API with GES Integration",
        'deepLinking': True,
        'defaultModelsExpandDepth': 2,
        'defaultModelExpandDepth': 2,
    }
)

app.register_blueprint(swaggerui_blueprint, url_prefix=SWAGGER_URL)

@app.route('/swagger.json')
def swagger_json():
    return get_swagger_json()

@app.route('/swagger.yaml')
def swagger_yaml():
    return get_swagger_yaml()

# Configure Flask-JWT-Extended
app.config["JWT_SECRET_KEY"] = os.getenv("JWT_SECRET_KEY", "dev-secret-key")
app.config["JWT_ACCESS_TOKEN_EXPIRES"] = timedelta(hours=1)
app.config["JWT_REFRESH_TOKEN_EXPIRES"] = timedelta(days=30)

# Authentication method
AUTH_METHOD = os.getenv("AUTH_METHOD", "file")

# GES Configuration
GES_ENABLED = os.getenv("GES_ENABLED", "false").lower() == "true"
GES_HOSTNAME = os.getenv("GES_HOSTNAME")
GES_PORT = int(os.getenv("GES_PORT", "8080"))
GES_NAMESPACE = os.getenv("GES_NAMESPACE", "default")
GES_CLIENT_ID = os.getenv("GES_CLIENT_ID")
GES_CLIENT_KEY = os.getenv("GES_CLIENT_KEY")

# Whether to always include base API key claims
ALWAYS_USE_BASE_CLAIMS = os.getenv("ALWAYS_USE_BASE_CLAIMS", "true").lower() == "true"

# Check if LDAP is requested but not available
if AUTH_METHOD == "ldap" and not LDAP_AVAILABLE:
    logger.warning("LDAP authentication method selected but python-ldap is not installed.")
    logger.warning("Falling back to file-based authentication.")
    AUTH_METHOD = "file"

# Initialize GES service if enabled
ges_service = None
if GES_ENABLED and GES_AVAILABLE:
    if all([GES_HOSTNAME, GES_CLIENT_ID, GES_CLIENT_KEY]):
        try:
            ges_service = EntitlementsService(
                hostname=GES_HOSTNAME,
                port=GES_PORT,
                namespace=GES_NAMESPACE,
                client_id=GES_CLIENT_ID,
                client_key=GES_CLIENT_KEY
            )
            logger.info("GES service initialized successfully")
        except Exception as e:
            logger.error(f"Failed to initialize GES service: {str(e)}")
            ges_service = None
    else:
        logger.warning("GES enabled but missing required configuration (hostname, client_id, client_key)")
        GES_ENABLED = False

jwt = JWTManager(app)

@app.route('/')
def index():
    return render_template('index.html')

def extract_group_cn(groups):
    """
    Extract group common names from LDAP group data
    """
    result = []
    for g in (groups or []):
        if isinstance(g, dict):
            cn = g.get('cn') or g.get('name') or g.get('uid') or ''
            if cn:
                result.append(cn.lower())
        elif isinstance(g, str):
            m = re.search(r'cn=([^,]+)', g, flags=re.I)
            result.append((m.group(1) if m else g).lower())
    seen, ordered = set(), []
    for n in result:
        if n not in seen:
            seen.add(n)
            ordered.append(n)
    return ordered

def get_ges_roles(username: str, namespace: str = None) -> list:
    """
    Get roles from GES service for a user in specific namespace
    """
    if not GES_ENABLED or not ges_service:
        logger.debug("GES not enabled or service not available")
        return []
    
    try:
        # If namespace is provided, use it; otherwise use default namespace
        target_namespace = namespace if namespace else GES_NAMESPACE
        
        # For simplicity, using the main service - in production you might need namespace switching
        roles = ges_service.get_roles(username)
        logger.info(f"Retrieved GES roles for {username} in namespace {target_namespace}: {roles}")
        return roles
    except Exception as e:
        logger.error(f"Error getting GES roles for {username}: {str(e)}")
        return []

def merge_groups_with_ges(ldap_groups: list, username: str, namespace: str = None) -> list:
    """
    Merge LDAP/File groups with GES roles
    """
    # Get normalized groups from LDAP/file
    normalized_ldap_groups = extract_group_cn(ldap_groups)
    
    # Get GES roles for the specified namespace
    ges_roles = get_ges_roles(username, namespace)
    
    # Combine and remove duplicates
    all_groups = list(set(normalized_ldap_groups + ges_roles))
    
    logger.info(f"Merged groups for {username}: LDAP/File={normalized_ldap_groups}, GES={ges_roles}, Combined={all_groups}")
    
    return all_groups

def check_pre_validation(api_key: str, normalized_groups: list, username: str) -> dict:
    """
    Enhanced pre-validation with GES namespace support
    """
    try:
        api_keys_dir = os.getenv("API_KEYS_DIR", "config/api_keys")
        api_key_file = os.path.join(api_keys_dir, f"{api_key}.yaml")
        
        if not os.path.exists(api_key_file):
            return {
                "valid": False,
                "message": "Invalid API key"
            }
        
        with open(api_key_file, 'r') as f:
            api_key_config = yaml.safe_load(f)
        
        # Check for namespace-based validation
        required_namespace = api_key_config.get('claims', {}).get('static', {}).get('ges_namespace')
        required_group = api_key_config.get('pre_validation_check')
        
        # If API key requires a specific namespace, validate namespace access
        if required_namespace and GES_ENABLED:
            ges_roles = get_ges_roles(username, required_namespace)
            has_namespace_access = len(ges_roles) > 0
            
            if not has_namespace_access:
                return {
                    "valid": False,
                    "message": f"User {username} does not have access to required namespace: {required_namespace}",
                    "required_namespace": required_namespace,
                    "validation_type": "namespace"
                }
            
            logger.info(f"User {username} has access to required namespace: {required_namespace}")
        
        # Continue with group-based validation if required
        if not required_group:
            return {
                "valid": True,
                "message": "No pre-validation required",
                "ges_namespace": required_namespace,
                "validation_type": "none"
            }
        
        required_group_normalized = required_group.lower()
        user_has_access = required_group_normalized in [group.lower() for group in normalized_groups]
        
        if user_has_access:
            return {
                "valid": True,
                "message": f"User has access to required group: {required_group}",
                "required_group": required_group,
                "ges_namespace": required_namespace,
                "validation_type": "group"
            }
        else:
            return {
                "valid": False,
                "message": f"User does not have access to required group: {required_group}",
                "required_group": required_group,
                "user_groups": normalized_groups,
                "ges_namespace": required_namespace,
                "validation_type": "group"
            }
            
    except Exception as e:
        logger.error(f"Error during pre-validation check: {str(e)}")
        return {
            "valid": False,
            "message": f"Error during validation: {str(e)}"
        }

@app.route('/token', methods=['POST'])
def login():
    if not request.is_json:
        return jsonify({"error": "Missing JSON in request"}), 400

    username = request.json.get('username', None)
    password = request.json.get('password', None)
    api_key = request.json.get('api_key', None)
    custom_secret = request.json.get('secret', None)

    if not username or not password:
        return jsonify({"error": "Missing username or password"}), 400

    # Authenticate based on the configured method
    if AUTH_METHOD == "ldap":
        authenticated, user_data = authenticate_ldap(username, password)
    else:
        authenticated, user_data = authenticate_file(username, password)

    if not authenticated:
        error_message = "Invalid username or password"
        if "error" in user_data:
            error_message = user_data["error"]
        return jsonify({"error": error_message}), 401
    
    # Create base user context (without GES initially)
    user_context = {
        "user_id": username,
        "email": user_data.get("email", ""),
        "groups": extract_group_cn(user_data.get("groups", [])),
        "roles": user_data.get("roles", []),
        "team_id": get_team_id_from_user(username, user_data)
    }

    api_key_namespace = None
    validation_type = "none"
    
    # If an API key was provided, check pre-validation and get additional claims
    if api_key:
        # Enhanced pre-validation with GES namespace support
        validation_result = check_pre_validation(api_key, user_context["groups"], username)
        if not validation_result["valid"]:
            return jsonify({
                "error": validation_result["message"],
                "required_group": validation_result.get("required_group"),
                "required_namespace": validation_result.get("ges_namespace"),
                "validation_type": validation_result.get("validation_type")
            }), 403
        
        api_key_namespace = validation_result.get("ges_namespace")
        validation_type = validation_result.get("validation_type", "none")
        
        # Enhanced user context with namespace info
        user_context.update({
            "api_key_id": api_key,
            "ges_namespace": api_key_namespace
        })
        
        # Get merged groups (LDAP + GES) if namespace is specified
        if api_key_namespace:
            merged_groups = merge_groups_with_ges(user_data.get("groups", []), username, api_key_namespace)
            user_context["groups"] = merged_groups
            user_context["ges_roles"] = get_ges_roles(username, api_key_namespace)
        
        logger.info(f"Processing API key with user_context: {user_context}")
        api_key_claims = get_additional_claims(api_key, user_context)
    else:
        api_key_claims = get_additional_claims(None, user_context)

    # Log which API key is being used
    if api_key:
        logger.info(f"Using provided API key: {api_key}, Namespace: {api_key_namespace}, Validation: {validation_type}")
    else:
        logger.info("No API key provided, using base API key")

    # Merge user data with additional claims
    claims = {**user_data, **api_key_claims}
    
    # Ensure groups in claims reflect the merged groups
    claims['groups'] = user_context["groups"]
    
    # Add GES namespace information to claims
    if api_key_namespace:
        claims['ges_namespace'] = api_key_namespace
        claims['ges_roles'] = user_context.get('ges_roles', [])
    
    # Get expiration time from API key configuration if available
    expires_delta = app.config["JWT_ACCESS_TOKEN_EXPIRES"]
    if 'exp_hours' in claims:
        expires_delta = timedelta(hours=claims['exp_hours'])
        logger.info(f"Using custom expiration time from API key: {claims['exp_hours']} hours")
        claims.pop('exp_hours')
    
    # If custom secret is provided, use it with PyJWT directly
    if custom_secret:
        import jwt
        import datetime as dt
        
        logger.info(f"Using custom secret for token generation")
        
        now = dt.datetime.now(dt.timezone.utc)
        access_token_exp = now + expires_delta
        refresh_token_exp = now + app.config["JWT_REFRESH_TOKEN_EXPIRES"]
        
        access_payload = {
            "iat": now,
            "nbf": now,
            "jti": str(uuid.uuid4()),
            "exp": access_token_exp,
            "sub": username,
            "type": "access",
            "fresh": True,
            **claims
        }
        
        refresh_payload = {
            "iat": now,
            "nbf": now,
            "jti": str(uuid.uuid4()),
            "exp": refresh_token_exp,
            "sub": username,
            "type": "refresh",
            **claims
        }
        
        algorithm = app.config.get('JWT_ALGORITHM', 'HS256')
        access_token = jwt.encode(access_payload, custom_secret, algorithm=algorithm)
        refresh_token = jwt.encode(refresh_payload, custom_secret, algorithm=algorithm)
        
        response_data = {
            "access_token": access_token,
            "refresh_token": refresh_token,
            "note": "Tokens generated with custom secret",
            "ges_enabled": GES_ENABLED,
            "ges_namespace": api_key_namespace,
            "validation_type": validation_type
        }
        
        if api_key_namespace:
            response_data["ges_roles"] = user_context.get('ges_roles', [])
        
        return jsonify(response_data), 200
    else:
        # Standard token creation with application secret
        access_token = create_access_token(
            identity=username, 
            additional_claims=claims,
            expires_delta=expires_delta,
            fresh=True
        )
        refresh_token = create_refresh_token(identity=username, additional_claims=claims)
        
        response_data = {
            "access_token": access_token, 
            "refresh_token": refresh_token,
            "ges_enabled": GES_ENABLED,
            "ges_namespace": api_key_namespace,
            "validation_type": validation_type
        }
        
        if api_key_namespace:
            response_data["ges_roles"] = user_context.get('ges_roles', [])
        
        return jsonify(response_data), 200

def get_team_id_from_user(username, user_data):
    """
    Determine the team ID from the user's data
    """
    groups = user_data.get("groups", [])
    
    if "administrators" in groups or "admins" in groups:
        return "admin-team"
    elif "ai-team" in groups:
        return "ai-team"
    elif "ml-team" in groups:
        return "ml-team"
    
    return "general-users"

# GES Management Endpoints
@app.route('/ges/status', methods=['GET'])
@jwt_required()
def ges_status():
    """
    Get GES service status and configuration
    """
    current_user = get_jwt_identity()
    
    status_info = {
        "ges_enabled": GES_ENABLED,
        "ges_available": GES_AVAILABLE,
        "ges_service_initialized": ges_service is not None,
        "current_user": current_user,
        "default_namespace": GES_NAMESPACE
    }
    
    if GES_ENABLED and ges_service:
        try:
            user_roles = get_ges_roles(current_user)
            status_info["user_ges_roles"] = user_roles
            status_info["connection_status"] = "healthy"
        except Exception as e:
            status_info["connection_status"] = f"error: {str(e)}"
    
    return jsonify(status_info), 200

@app.route('/ges/roles/<username>', methods=['GET'])
@jwt_required()
def get_user_ges_roles(username):
    """
    Get GES roles for a specific user (admin only)
    """
    # Check if user has admin privileges
    claims = get_jwt()
    groups = claims.get('groups', [])
    
    if 'administrators' not in groups and 'admins' not in groups:
        return jsonify({"error": "Administrator access required"}), 403
    
    if not GES_ENABLED or not ges_service:
        return jsonify({"error": "GES service not available"}), 503
    
    try:
        roles = ges_service.get_roles(username)
        return jsonify({
            "username": username,
            "ges_roles": roles,
            "timestamp": datetime.now().isoformat()
        }), 200
    except Exception as e:
        logger.error(f"Error getting GES roles for {username}: {str(e)}")
        return jsonify({"error": f"Failed to get GES roles: {str(e)}"}), 500

@app.route('/ges/namespaces', methods=['GET'])
@jwt_required()
def get_ges_namespaces():
    """
    Get available namespaces and user access
    """
    current_user = get_jwt_identity()
    
    if not GES_ENABLED:
        return jsonify({"error": "GES service not enabled"}), 503
    
    # In a real implementation, you would query GES for available namespaces
    # For now, return the configured namespace and any from API keys
    namespaces_info = {
        "username": current_user,
        "available_namespaces": [GES_NAMESPACE],
        "default_namespace": GES_NAMESPACE
    }
    
    # Check API keys for additional namespaces
    api_keys_dir = os.getenv("API_KEYS_DIR", "config/api_keys")
    if os.path.exists(api_keys_dir):
        unique_namespaces = set()
        for key_file in glob.glob(os.path.join(api_keys_dir, "*.yaml")):
            try:
                with open(key_file, 'r') as f:
                    key_data = yaml.safe_load(f)
                    namespace = key_data.get('claims', {}).get('static', {}).get('ges_namespace')
                    if namespace:
                        unique_namespaces.add(namespace)
            except Exception as e:
                logger.error(f"Error reading API key file {key_file}: {str(e)}")
        
        if unique_namespaces:
            namespaces_info["available_namespaces"].extend(list(unique_namespaces))
    
    return jsonify(namespaces_info), 200

# Existing endpoints remain the same...
@app.route('/refresh', methods=['POST'])
@jwt_required(refresh=True)
def refresh():
    current_user = get_jwt_identity()
    jwt_claims = get_jwt()
    
    reserved_claims = ['exp', 'iat', 'nbf', 'jti', 'type', 'fresh']
    additional_claims = {key: value for key, value in jwt_claims.items() 
                         if key not in reserved_claims}
    
    access_token = create_access_token(
        identity=current_user,
        additional_claims=additional_claims
    )
    
    logger.info(f"Refreshing token for user {current_user}")
    
    return jsonify(access_token=access_token), 200

@app.route('/decode', methods=['POST'])
def decode():
    if not request.is_json:
        return jsonify({"error": "Missing JSON in request"}), 400

    token = request.json.get('token', None)
    if not token:
        return jsonify({"error": "Missing token"}), 400
        
    skip_verification = request.json.get('skipVerification', False)
    custom_secret = request.json.get('secret')
    
    secret_key = custom_secret if custom_secret else app.config['JWT_SECRET_KEY']
    algorithm = app.config.get('JWT_ALGORITHM', 'HS256')
    
    try:
        import jwt
        if custom_secret:
            decoded = jwt.decode(token, secret_key, algorithms=[algorithm])
            decoded["note"] = "Decoded using provided custom secret"
        else:
            decoded = decode_token(token)
        return jsonify(decoded), 200
    except Exception as e:
        if skip_verification:
            try:
                import jwt
                decoded = jwt.decode(token, options={"verify_signature": False})
                decoded["warning"] = "Token signature verification was skipped!"
                return jsonify(decoded), 200
            except Exception as inner_e:
                return jsonify({"error": f"Invalid token format: {str(inner_e)}"}), 400
        else:
            error_msg = str(e)
            if custom_secret:
                error_msg += " (using provided custom secret)"
            return jsonify({"error": error_msg}), 400

@app.route('/validate', methods=['POST'])
def validate_token():
    if not request.is_json:
        return jsonify({"error": "Missing JSON in request"}), 400

    token = request.json.get('token', None)
    if not token:
        return jsonify({"error": "Missing token"}), 400
    
    try:
        decoded = decode_token(token)
        expiry = datetime.utcfromtimestamp(decoded['exp']).strftime('%Y-%m-%d %H:%M:%S UTC')
        issue_time = datetime.utcfromtimestamp(decoded['iat']).strftime('%Y-%m-%d %H:%M:%S UTC')
        is_expired = datetime.utcfromtimestamp(decoded['exp']) < datetime.utcnow()
        
        return jsonify({
            "valid": True,
            "signature_verified": True,
            "expired": is_expired,
            "expiry_time": expiry,
            "issued_at": issue_time,
            "issuer": decoded.get('iss', 'Not specified'),
            "subject": decoded.get('sub', 'Not specified'),
            "ges_namespace": decoded.get('ges_namespace'),
            "ges_roles": decoded.get('ges_roles', [])
        }), 200
    except Exception as e:
        error_msg = str(e)
        signature_failed = "signature" in error_msg.lower()
        expired = "expired" in error_msg.lower()
        
        return jsonify({
            "valid": False,
            "signature_verified": not signature_failed,
            "expired": expired,
            "error": error_msg
        }), 200

@app.route('/protected', methods=['GET'])
@jwt_required()
def protected():
    current_user = get_jwt_identity()
    jwt_claims = get_jwt()
    
    return jsonify({
        "logged_in_as": current_user,
        "ges_namespace": jwt_claims.get('ges_namespace'),
        "ges_roles": jwt_claims.get('ges_roles', [])
    }), 200

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=int(os.getenv('PORT', 5000)))
