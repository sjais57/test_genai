package ak_tiered_model_exec

# Default deny for all requests
default allow = false

# Main authorization rule
allow {
    # Check if user's group matches any category
    user_category := get_user_category(input.user_groups)
    user_category != ""

    # Check if requested model is allowed
    valid_model(input.model)

    # Check rate limits
    within_rate_limit
}

# Get user category based on groups
get_user_category(groups) = category {
    some category_name, category_data in input.metadata.categories
    some group in groups
    group in category_data.groups
    category = category_name
} else = "" {
    true
}

# Check if model is allowed
valid_model(model) {
    model == input.claims.static.models[_]
}

# Check rate limiting
within_rate_limit {
    input.claims.static.rate_limit > count(requests)
}

# Get team permissions
get_team_permissions(team_id) = permissions {
    permissions := input.metadata.team_permissions[team_id]
}

# Get destination URL based on user category
get_destination_url(user_groups) = url {
    category := get_user_category(user_groups)
    url := input.metadata.categories[category].destURL
}

# Get allowed domains
allowed_domains = domains {
    domains := input.metadata.request_data.allowed_domains
}

# Get model configuration
get_model_config = config {
    config := input.metadata.function_params.model_config.default_params
}

# Get logging configuration
get_logging_config = config {
    config := {
        "level": input.metadata.function_params.logging.level,
        "detailed_errors": input.metadata.function_params.logging.detailed_errors
    }
}

# Get test scenarios (parsed from JSON string)
get_test_scenarios = scenarios {
    scenarios := json.unmarshal(input.metadata.json_data).test_scenarios
}

# Helper function to check if user has specific permission
has_permission(team_id, permission) {
    permissions := get_team_permissions(team_id)
    permissions[permission] == true
}

# Get service tier information
get_service_tier = tier {
    tier := input.metadata.context.service_tier
}

# Get deployment region
get_deployment_region = region {
    region := input.metadata.context.deployment_region
}
