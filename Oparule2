# policy.rego
package meta.eval

# Default when nothing matches
default fallback := ["public"]

# Convenience: sorted unique
sorted_uniq(xs) := array.sort(array.fromset(xs))

# Helpers
any_exact_match(groups, m) {
  m.match_type == "exact"
  g := m.groups[_]
  groups[_] == g
}

any_prefix_match(groups, m) {
  m.match_type == "startswith"
  gp := m.groups_prefix[_]
  some g
  groups[_] == g
  startswith(g, gp)
}

# Collect all classifications that match any user group
classifications[c] {
  m := data.metadata.metadata_filter[_]
  any_exact_match(input.user_groups, m)  # exact match
  c := m.classification[_]
}
classifications[c] {
  m := data.metadata.metadata_filter[_]
  any_prefix_match(input.user_groups, m) # startswith match
  c := m.classification[_]
}

# Final shape you asked for
metadata_filter := {"classification": classes} {
  classes := sorted_uniq([c | c := classifications[_]])
}

# Optional: expose just the list as well
classes := sorted_uniq([c | c := classifications[_]])



# rules.yaml
metadata:
  metadata_filter:
    - match_type: "startswith"
      groups_prefix: ["grp_tier1_", "unix_"]
      classification: ["confidential", "proprietary"]
    - match_type: "exact"
      groups: ["grp_tier", "contributors"]
      classification: ["confidential"]
    - match_type: "exact"
      groups: ["groups4"]
      classification: ["internal"]


opa eval -I \
  -d policy.rego \
  -d rules.yaml \
  -i input.json \
  'data.meta.eval.metadata_filter' -f pretty
