package meta.eval

# ---- Hardcoded rules table (edit as needed) ----
rules := [
  {"type": "startswith", "prefixes": ["grp_tier1_", "unix_"], "cls": ["confidential", "proprietary"]},
  {"type": "exact",      "groups":   ["grp_tier", "contributors"], "cls": ["confidential"]},
  {"type": "exact",      "groups":   ["groups4"],                   "cls": ["internal"]}
]

# ---- Collect matching classifications (partial set uses `contains`) ----
match_classes contains c if {
  r := rules[_]
  r.type == "exact"
  g := r.groups[_]
  input.user_groups[_] == g
  c := r.cls[_]
}
match_classes contains c if {
  r := rules[_]
  r.type == "startswith"
  p := r.prefixes[_]
  some g
  input.user_groups[_] == g
  startswith(g, p)
  c := r.cls[_]
}

# ---- Sorted, unique list from the set ----
classes := array.sort(array.fromset([c | match_classes contains c]))

# ---- Final output with fallback ----
metadata_filter := {"classification": classes} if { count(classes) > 0 }
metadata_filter := {"classification": ["public"]} if { count(classes) == 0 }
