package meta.eval

default fallback := ["public"]

# --- rules table embedded in the policy (no YAML) ---
rules = [
  {
    "match_type": "startswith",
    "groups_prefix": ["grp_tier1_", "unix_"],
    "classification": ["confidential", "proprietary"]
  },
  {
    "match_type": "exact",
    "groups": ["grp_tier", "contributors"],
    "classification": ["confidential"]
  },
  {
    "match_type": "exact",
    "groups": ["groups4"],
    "classification": ["internal"]
  }
] if { true }

# --- helpers ---
# exact group match?
exact_match(m, groups) if {
  m.match_type == "exact"
  mg := m.groups[_]
  groups[_] == mg
}

# prefix match?
prefix_match(m, groups) if {
  m.match_type == "startswith"
  gp := m.groups_prefix[_]
  some g
  groups[_] == g
  startswith(g, gp)
}

# collect matching classifications (partial set uses `contains` in v1)
classifications contains c if {
  m := rules[_]
  exact_match(m, input.user_groups)
  c := m.classification[_]
}
classifications contains c if {
  m := rules[_]
  prefix_match(m, input.user_groups)
  c := m.classification[_]
}

# unique + sorted list
classes = out if {
  out := array.sort(array.fromset([c | classifications contains c]))
}

# final output (with fallback when nothing matches)
metadata_filter = {"classification": classes} if { count(classes) > 0 }
metadata_filter = {"classification": fallback} if { count(classes) == 0 }
