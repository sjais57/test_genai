package meta.eval

default fallback := ["public"]

# helper: sorted unique
sorted_uniq(xs) := array.sort(array.fromset(xs))

# boolean: does rule m match by exact group?
exact_match(m, groups) {
  m.match_type == "exact"
  mg := m.groups[_]
  groups[_] == mg
}

# boolean: does rule m match by prefix?
prefix_match(m, groups) {
  m.match_type == "startswith"
  gp := m.groups_prefix[_]
  some g
  groups[_] == g
  startswith(g, gp)
}

# collect classifications for matches (two bodies = disjunction)
classifications[c] {
  m := data.metadata.metadata_filter[_]
  exact_match(m, input.user_groups)
  c := m.classification[_]
}
classifications[c] {
  m := data.metadata.metadata_filter[_]
  prefix_match(m, input.user_groups)
  c := m.classification[_]
}

# final outputs
classes := sorted_uniq([c | c := classifications[_]])

metadata_filter := {"classification": classes}

# (optional) fallback if nothing matched:
# metadata_filter := {"classification": fallback} { count(classes) == 0 }
