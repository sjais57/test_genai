package meta.eval

default fallback := ["public"]

# --- match helpers (boolean rules) ---
exact_match(m, groups) if {
  m.match_type == "exact"
  mg := m.groups[_]
  groups[_] == mg
}


prefix_match(m, groups) if {
  m.match_type == "startswith"
  gp := m.groups_prefix[_]
  some g
  groups[_] == g
  startswith(g, gp)
}

# --- collect matching classifications (partial set, v1 uses `contains`) ---
classifications contains c if {
  m := data.metadata.metadata_filter[_]
  exact_match(m, input.user_groups)
  c := m.classification[_]
}
classifications contains c if {
  m := data.metadata.metadata_filter[_]
  prefix_match(m, input.user_groups)
  c := m.classification[_]
}

# unique + sorted list
classes = out if {
  out := array.sort(array.fromset([c | classifications contains c]))
}

# final result (with fallback if nothing matched)
metadata_filter = {"classification": classes} if { count(classes) > 0 }
metadata_filter = {"classification": fallback} if { count(classes) == 0 }
