package meta.eval

default fallback := ["public"]

# Sorted unique helper
sorted_uniq(xs) = out {
    out := array.sort(array.fromset(xs))
}

# Boolean rule: does m have an exact group match?
any_exact_match(groups, m) {
    m.match_type == "exact"
    g := m.groups[_]
    groups[_] == g
}

# Boolean rule: does m have a prefix match?
any_prefix_match(groups, m) {
    m.match_type == "startswith"
    gp := m.groups_prefix[_]
    some g
    groups[_] == g
    startswith(g, gp)
}

# Collect all classifications for matching rules
classifications[c] {
    m := data.metadata.metadata_filter[_]
    any_exact_match(input.user_groups, m)
    c := m.classification[_]
}
classifications[c] {
    m := data.metadata.metadata_filter[_]
    any_prefix_match(input.user_groups, m)
    c := m.classification[_]
}

# Final output
metadata_filter := {"classification": classes} {
    classes := sorted_uniq([c | c := classifications[_]])
}
