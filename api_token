import os
import yaml
import json
import logging
import importlib
import requests
import datetime
from typing import Dict, Any, Optional, Callable, Union, Tuple, List
from datetime import datetime, timedelta
from cachetools import TTLCache

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Define the name of the base API key file
BASE_API_KEY_FILE = "base_api_key.yaml"

# Try to import GES EntitlementsService
try:
    from ges_entitylements.security import EntitlementsService
    GES_ENTITLEMENTS_AVAILABLE = True
    logger.info("GES EntitlementsService package is available")
except ImportError:
    GES_ENTITLEMENTS_AVAILABLE = False
    logger.warning("ges_entitylements package not available. GES entitlements service will be disabled.")

class GESClaimsService:
    """
    Service to fetch user claims from GES portal using EntitlementsService
    """
    
    def __init__(self):
        self.ges_hostname = os.getenv("GES_HOSTNAME", "")
        self.ges_port = os.getenv("GES_PORT", "443")
        self.ges_client_id = os.getenv("GES_CLIENT_ID", "test")
        self.ges_client_key = os.getenv("GES_CLIENT_KEY", "test123")
        self.ges_enabled = bool(self.ges_hostname and GES_ENTITLEMENTS_AVAILABLE)
        self.cache = TTLCache(maxsize=1000, ttl=300)  # 5-minute cache
        self.entitlements_services = {}  # Cache EntitlementsService instances by namespace
        
    def get_entitlements_service(self, namespace: str) -> Optional[EntitlementsService]:
        """
        Get or create an EntitlementsService instance for a namespace
        """
        if namespace not in self.entitlements_services:
            try:
                self.entitlements_services[namespace] = EntitlementsService(
                    hostname=self.ges_hostname,
                    port=self.ges_port,
                    namespace=namespace,
                    client_id=self.ges_client_id,
                    client_key=self.ges_client_key
                )
                logger.info(f"Created EntitlementsService for namespace: {namespace}")
            except Exception as e:
                logger.error(f"Failed to create EntitlementsService for namespace {namespace}: {str(e)}")
                return None
        
        return self.entitlements_services.get(namespace)
        
    def get_user_claims(self, username: str, namespace: str = None) -> Dict[str, Any]:
        """
        Fetch user claims from GES portal using EntitlementsService
        
        Args:
            username: The username to fetch claims for
            namespace: The namespace (if not provided, uses default from env)
        """
        if not self.ges_enabled:
            logger.warning("GES claims service is not enabled")
            return {}
        
        # Use provided namespace or default from environment
        namespace = namespace or os.getenv("GES_DEFAULT_NAMESPACE", "default")
        
        cache_key = f"ges_claims_{namespace}_{username}"
        if cache_key in self.cache:
            logger.info(f"Returning cached GES claims for {username} in namespace {namespace}")
            return self.cache[cache_key]
        
        try:
            # Get the EntitlementsService for this namespace
            service = self.get_entitlements_service(namespace)
            if not service:
                logger.error(f"Could not get EntitlementsService for namespace: {namespace}")
                return {}
            
            # Fetch roles using the EntitlementsService
            logger.info(f"Fetching GES roles for user {username} in namespace {namespace}")
            roles = service.get_roles(username)
            
            # Process the roles into claims
            processed_claims = self._process_ges_claims(roles, username, namespace)
            
            # Cache the result
            self.cache[cache_key] = processed_claims
            logger.info(f"Successfully fetched {len(roles)} GES roles for user {username} in namespace {namespace}")
            return processed_claims
            
        except Exception as e:
            logger.error(f"Error fetching GES claims for user {username} in namespace {namespace}: {str(e)}")
            return {}
    
    def _process_ges_claims(self, roles: List[str], username: str, namespace: str) -> Dict[str, Any]:
        """
        Process GES roles into standardized claims format
        """
        if not roles:
            return {}
        
        # Convert roles to lowercase for consistency
        normalized_roles = [role.lower() for role in roles if isinstance(role, str)]
        
        processed_claims = {
            "ges_roles": normalized_roles,
            "ges_groups": normalized_roles,  # Treat roles as groups for compatibility
            "ges_namespace": namespace,
            "ges_source": "EntitlementsService"
        }
        
        # Add derived claims based on roles
        derived_claims = self._derive_claims_from_roles(normalized_roles)
        processed_claims.update(derived_claims)
        
        return processed_claims
    
    def _derive_claims_from_roles(self, roles: List[str]) -> Dict[str, Any]:
        """
        Derive additional claims based on GES roles
        """
        derived_claims = {}
        
        # Determine if user is admin
        is_admin = any(role in ['admin', 'administrator', 'superuser'] for role in roles)
        if is_admin:
            derived_claims["is_admin"] = True
            derived_claims["max_rate_limit"] = 1000
            derived_claims["tier"] = "premium"
        
        # Determine team based on roles
        team_mapping = {
            'ai-team': 'ai-team',
            'ml-team': 'ml-team', 
            'data-science': 'ds-team',
            'developers': 'dev-team',
            'researchers': 'research-team'
        }
        
        for role in roles:
            for team_key, team_value in team_mapping.items():
                if team_key in role:
                    derived_claims["team"] = team_value
                    break
            if "team" in derived_claims:
                break
        else:
            derived_claims["team"] = "general-users"
        
        # Set tier based on roles
        if any(role in ['premium', 'vip', 'gold'] for role in roles):
            derived_claims["tier"] = "premium"
            derived_claims["max_tokens"] = 4000
        elif any(role in ['standard', 'user', 'silver'] for role in roles):
            derived_claims["tier"] = "standard" 
            derived_claims["max_tokens"] = 2000
        else:
            derived_claims["tier"] = "basic"
            derived_claims["max_tokens"] = 1000
        
        # Set permissions based on roles
        derived_claims["can_manage_api_keys"] = is_admin or any(role in ['api-admin', 'key-manager'] for role in roles)
        derived_claims["can_access_sensitive"] = is_admin or any(role in ['sensitive-access', 'privileged'] for role in roles)
        
        return derived_claims

# Initialize GES service
ges_claims_service = GESClaimsService()

def get_api_key_metadata(api_key: str = None) -> Dict[str, Any]:
    """
    Get metadata from the API key configuration file.
    This metadata is not included in JWT tokens but can be used for function calls and API requests.
    
    Args:
        api_key: The API key to look up, if None or empty, will use the base API key
    
    Returns:
        Dict containing the metadata from the API key configuration
    """
    try:
        # Get API keys directory path from environment variable or use default
        api_keys_dir = os.getenv("API_KEYS_DIR", "config/api_keys")
        
        # Check if directory exists
        if not os.path.exists(api_keys_dir):
            logger.error(f"API keys directory not found: {api_keys_dir}")
            return {}
        
        # Determine which API key file to use
        api_key_file = None
        
        # If API key is provided, try to find its config file
        if api_key:
            specific_key_file = os.path.join(api_keys_dir, f"{api_key}.yaml")
            if os.path.exists(specific_key_file):
                api_key_file = specific_key_file
            else:
                logger.warning(f"Config file for API key not found: {api_key}")
                logger.info("Falling back to base API key")
        
        # If no API key provided or specific key not found, use the base API key
        if not api_key_file:
            base_key_file = os.path.join(api_keys_dir, BASE_API_KEY_FILE)
            if os.path.exists(base_key_file):
                api_key_file = base_key_file
                logger.info("Using base API key")
            else:
                logger.warning(f"Base API key file not found: {BASE_API_KEY_FILE}")
                return {}
        
        # Load API key config from file
        with open(api_key_file, 'r') as f:
            key_data = yaml.safe_load(f)
        
        # Extract metadata section
        metadata = key_data.get('metadata', {})
        
        return metadata
        
    except Exception as e:
        logger.error(f"Unexpected error getting API key metadata: {str(e)}")
        return {}


def get_api_key_data(api_key: str = None, user_context: Dict[str, Any] = None) -> Dict[str, Any]:
    """
    Get both claims and metadata from an API key configuration in a single call.
    This is useful for testing scenarios where you need access to both JWT claims and external metadata.
    
    Args:
        api_key: The API key to look up, if None or empty, will use the base API key
        user_context: Optional context about the user (e.g., user_id, team_id)
        
    Returns:
        Dict containing both 'claims' and 'metadata' keys with their respective data
    """
    claims = get_additional_claims(api_key, user_context)
    metadata = get_api_key_metadata(api_key)
    
    return {
        "claims": claims,
        "metadata": metadata
    }

def get_additional_claims(api_key: str = None, user_context: Dict[str, Any] = None) -> Dict:
    """
    Get additional claims based on the provided API key
    
    Args:
        api_key: The API key to look up, if None or empty, will use the base API key
        user_context: Optional context about the user (e.g., user_id, team_id)
        
    Returns:
        Dict with additional claims to include in the JWT token
    """
    try:
        if user_context is None:
            user_context = {}
            
        # Get API keys directory path from environment variable or use default
        api_keys_dir = os.getenv("API_KEYS_DIR", "config/api_keys")
        
        # Check if directory exists
        if not os.path.exists(api_keys_dir):
            logger.error(f"API keys directory not found: {api_keys_dir}")
            return {}
        
        # Determine which API key file to use
        api_key_file = None
        
        # If API key is provided, try to find its config file
        if api_key:
            specific_key_file = os.path.join(api_keys_dir, f"{api_key}.yaml")
            if os.path.exists(specific_key_file):
                api_key_file = specific_key_file
            else:
                logger.warning(f"Config file for API key not found: {api_key}")
                logger.info("Falling back to base API key")
        
        # If no API key provided or specific key not found, use the base API key
        if not api_key_file:
            base_key_file = os.path.join(api_keys_dir, BASE_API_KEY_FILE)
            if os.path.exists(base_key_file):
                api_key_file = base_key_file
                logger.info("Using base API key")
            else:
                logger.warning(f"Base API key file not found: {BASE_API_KEY_FILE}")
                return {}
        
        # Load API key config from file
        with open(api_key_file, 'r') as f:
            key_data = yaml.safe_load(f)
        
        # Extract static claims
        static_claims = key_data.get('claims', {}).get('static', {})
        
        # Get GES configuration from API key metadata
        metadata = key_data.get('metadata', {})
        ges_config = metadata.get('ges', {})
        use_ges_claims = ges_config.get('enabled', False)
        ges_namespace = ges_config.get('namespace') or os.getenv("GES_DEFAULT_NAMESPACE", "default")
        
        # Get AD groups from user context (existing functionality)
        ad_groups = user_context.get('groups', [])
        ad_roles = user_context.get('roles', [])
        
        # Initialize combined claims
        combined_claims = {**static_claims}
        
        # Add AD groups and roles to claims
        if ad_groups:
            combined_claims["ad_groups"] = ad_groups
        if ad_roles:
            combined_claims["ad_roles"] = ad_roles
        
        # Add GES claims if enabled
        if use_ges_claims:
            username = user_context.get('user_id')
            if username:
                ges_claims = ges_claims_service.get_user_claims(username, ges_namespace)
                if ges_claims:
                    # Merge GES claims with existing claims
                    combined_claims = {**combined_claims, **ges_claims}
                    logger.info(f"Merged GES claims for user {username} from namespace {ges_namespace}")
                else:
                    logger.warning(f"No GES claims found for user {username} in namespace {ges_namespace}")
        
        # Process dynamic claims (supports both AD and GES data)
        dynamic_claims = process_dynamic_claims(
            key_data.get('claims', {}).get('dynamic', {}),
            user_context,
            api_key or "base_api_key",
            key_data.get('id', ''),
            metadata
        )
        
        # Combine all claims
        additional_claims = {**combined_claims, **dynamic_claims}
        
        # Add claim source information
        additional_claims["claim_sources"] = []
        if ad_groups:
            additional_claims["claim_sources"].append("AD")
        if use_ges_claims:
            additional_claims["claim_sources"].append("GES")
        if dynamic_claims:
            additional_claims["claim_sources"].append("Dynamic")
        
        return additional_claims
        
    except Exception as e:
        logger.error(f"Unexpected error getting additional claims: {str(e)}")
        return {}

def process_dynamic_claims(
    dynamic_claims_config: Dict[str, Any],
    user_context: Dict[str, Any],
    api_key: str,
    api_key_id: str,
    metadata: Dict[str, Any] = None
) -> Dict[str, Any]:
    logger.info(f"Processing dynamic claims with user_context={user_context}, api_key={api_key}, api_key_id={api_key_id}")
    """
    Process dynamic claims configuration and execute the specified functions or API calls
    
    Args:
        dynamic_claims_config: Configuration for dynamic claims
        user_context: Context about the user (e.g., user_id, team_id)
        api_key: The original API key string
        api_key_id: The ID associated with the API key
        
    Returns:
        Dict with resolved dynamic claims
    """
    if not dynamic_claims_config:
        return {}
    
    result = {}
    
    logger.info(f"Dynamic claims config: {dynamic_claims_config}")
    for claim_name, claim_config in dynamic_claims_config.items():
        logger.info(f"Processing claim: {claim_name} with config: {claim_config}")
        try:
            claim_type = claim_config.get('type', '')
            
            if claim_type == 'function':
                claim_value = execute_function_claim(claim_config, user_context, api_key, api_key_id, metadata)
                if claim_value:
                    result[claim_name] = claim_value
                    
            elif claim_type == 'api':
                # Call an external API to get the claim value
                claim_value = execute_api_claim(claim_config, user_context, api_key, api_key_id)
                if claim_value:
                    result[claim_name] = claim_value
                    
            elif claim_type == 'ges':
                # Process GES-based dynamic claims
                claim_value = execute_ges_claim(claim_config, user_context, api_key, api_key_id)
                if claim_value:
                    result[claim_name] = claim_value
                    
            elif claim_type == 'formula':
                # Process formula-based claims
                formulas = claim_config.get('formulas', {})
                formula_claims = execute_formula_claims(formulas, user_context, result, api_key, api_key_id)
                result.update(formula_claims)
                    
            else:
                logger.warning(f"Unknown claim type: {claim_type} for claim: {claim_name}")
                
        except Exception as e:
            logger.error(f"Error processing dynamic claim '{claim_name}': {str(e)}")
    
    logger.info(f"Final dynamic claims result: {result}")
    return result

def execute_ges_claim(
    claim_config: Dict[str, Any],
    user_context: Dict[str, Any],
    api_key: str,
    api_key_id: str
) -> Optional[Any]:
    """
    Execute a GES-based dynamic claim
    
    Args:
        claim_config: Configuration for the GES claim
        user_context: Context about the user
        api_key: The original API key string
        api_key_id: The ID associated with the API key
        
    Returns:
        The claim value from GES, or None if execution failed
    """
    try:
        username = user_context.get('user_id')
        if not username:
            logger.error("User ID not found in user_context for GES claim")
            return None
        
        # Get API key configuration to extract namespace
        api_keys_dir = os.getenv("API_KEYS_DIR", "config/api_keys")
        api_key_file = os.path.join(api_keys_dir, f"{api_key}.yaml")
        
        if not os.path.exists(api_key_file):
            logger.error(f"API key file not found: {api_key_file}")
            return None
        
        with open(api_key_file, 'r') as f:
            key_data = yaml.safe_load(f)
        
        # Get namespace from API key metadata
        metadata = key_data.get('metadata', {})
        ges_config = metadata.get('ges', {})
        namespace = claim_config.get('namespace') or ges_config.get('namespace') or os.getenv("GES_DEFAULT_NAMESPACE", "default")
        
        claim_field = claim_config.get('field')  # e.g., 'ges_roles', 'ges_groups'
        
        # Get GES claims
        ges_claims = ges_claims_service.get_user_claims(username, namespace)
        
        if not ges_claims:
            logger.warning(f"No GES claims found for user {username} in namespace {namespace}")
            return claim_config.get('default_value')
        
        # Extract specific field if requested
        if claim_field:
            # Support nested fields using dot notation
            parts = claim_field.split('.')
            value = ges_claims
            for part in parts:
                if isinstance(value, dict) and part in value:
                    value = value[part]
                else:
                    logger.warning(f"GES claim field '{claim_field}' not found for user {username}")
                    return claim_config.get('default_value')
            return value
        
        # Return all GES claims if no specific field requested
        return ges_claims
        
    except Exception as e:
        logger.error(f"Error executing GES claim: {str(e)}")
        return None

def execute_function_claim(
    claim_config: Dict[str, Any],
    user_context: Dict[str, Any],
    api_key: str,
    api_key_id: str,
    metadata: Dict[str, Any] = None
) -> Optional[Any]:
    logger.info(f"Executing function claim with config: {claim_config}")
    """
    Execute a function-based dynamic claim
    
    Args:
        claim_config: Configuration for the function claim
        user_context: Context about the user
        api_key: The original API key string
        api_key_id: The ID associated with the API key
        
    Returns:
        The claim value returned by the function, or None if execution failed
    """
    try:
        module_name = claim_config.get('module')
        function_name = claim_config.get('function')
        
        if not module_name or not function_name:
            logger.error("Missing module or function name in function claim configuration")
            return None
        
        # Import the module
        module = importlib.import_module(module_name)
        
        # Get the function
        func = getattr(module, function_name)
        
        # Prepare arguments
        args = claim_config.get('args', {})
        processed_args = {}
        
        # Replace placeholders in arguments with values from context
        for arg_name, arg_value in args.items():
            if isinstance(arg_value, str) and arg_value.startswith('{') and arg_value.endswith('}'):
                # Extract the placeholder name
                placeholder = arg_value[1:-1]
                
                if placeholder == 'api_key':
                    processed_args[arg_name] = api_key
                elif placeholder == 'api_key_id':
                    processed_args[arg_name] = api_key_id
                else:
                    # Look for the value in user_context
                    processed_args[arg_name] = user_context.get(placeholder, '')
            else:
                processed_args[arg_name] = arg_value
        
        # Call the function with the processed arguments and metadata if available
        if metadata is not None:
            return func(**processed_args, metadata=metadata)
        else:
            return func(**processed_args)
        
    except Exception as e:
        logger.error(f"Error executing function claim: {str(e)}")
        return None

def execute_api_claim(
    claim_config: Dict[str, Any],
    user_context: Dict[str, Any],
    api_key: str,
    api_key_id: str
) -> Optional[Any]:
    """
    Execute an API-based dynamic claim
    
    Args:
        claim_config: Configuration for the API claim
        user_context: Context about the user
        api_key: The original API key string
        api_key_id: The ID associated with the API key
        
    Returns:
        The claim value returned by the API, or None if execution failed
    """
    try:
        url = claim_config.get('url')
        method = claim_config.get('method', 'GET')
        headers = claim_config.get('headers', {})
        response_field = claim_config.get('response_field')
        
        if not url:
            logger.error("Missing URL in API claim configuration")
            return None
        
        # Replace placeholders in URL
        processed_url = url
        for placeholder, value in {
            '{api_key}': api_key,
            '{api_key_id}': api_key_id,
            **{f'{{{k}}}': v for k, v in user_context.items()}
        }.items():
            processed_url = processed_url.replace(placeholder, str(value))
        
        # Replace placeholders in headers
        processed_headers = {}
        for header_name, header_value in headers.items():
            if isinstance(header_value, str) and '{' in header_value and '}' in header_value:
                for placeholder, value in {
                    '{api_key}': api_key,
                    '{api_key_id}': api_key_id,
                    '{internal_token}': os.getenv('INTERNAL_API_TOKEN', ''),
                    **{f'{{{k}}}': v for k, v in user_context.items()}
                }.items():
                    header_value = header_value.replace(placeholder, str(value))
            processed_headers[header_name] = header_value
        
        # Make the API request
        response = requests.request(
            method=method,
            url=processed_url,
            headers=processed_headers,
            timeout=5  # 5 second timeout
        )
        
        # Check if the request was successful
        if response.status_code != 200:
            logger.error(f"API request failed with status code {response.status_code}: {response.text}")
            return None
        
        # Parse the response
        response_data = response.json()
        
        # Extract the specified field if provided
        if response_field:
            # Support for nested fields using dot notation (e.g., "data.user.quota")
            parts = response_field.split('.')
            value = response_data
            for part in parts:
                if part in value:
                    value = value[part]
                else:
                    logger.error(f"Response field '{response_field}' not found in API response")
                    return None
            return value
        
        return response_data
        
    except Exception as e:
        logger.error(f"Error executing API claim: {str(e)}")
        return None

def execute_formula_claims(
    formulas: Dict[str, str],
    user_context: Dict[str, Any],
    existing_claims: Dict[str, Any],
    api_key: str,
    api_key_id: str
) -> Dict[str, Any]:
    """
    Execute formula-based dynamic claims with enhanced GES and AD support
    
    Args:
        formulas: Dictionary of formula-based claims with claim name as key and formula as value
        user_context: Context about the user
        existing_claims: Claims that have already been processed (static and dynamic)
        api_key: The original API key string
        api_key_id: The ID associated with the API key
        
    Returns:
        Dictionary of evaluated formula claims
    """
    try:
        # If no formulas defined, return empty dict
        if not formulas:
            return {}
            
        # Enhanced formula evaluator with GES and AD support
        result = {}
        
        # Define helper functions for formula evaluation
        def now():
            return datetime.now()
            
        def hours(h):
            return timedelta(hours=h)
            
        def days(d):
            return timedelta(days=d)
            
        def min_val(a, b):
            return min(a, b)
            
        def max_val(a, b):
            return max(a, b)
            
        def is_in(item, collection):
            if isinstance(collection, (list, tuple, set)):
                return item in collection
            return False
            
        def has_any_role(roles_to_check, user_roles):
            """Check if user has any of the specified roles"""
            if not isinstance(user_roles, list):
                return False
            return any(role in user_roles for role in roles_to_check)
            
        def has_all_roles(roles_to_check, user_roles):
            """Check if user has all of the specified roles"""
            if not isinstance(user_roles, list):
                return False
            return all(role in user_roles for role in roles_to_check)
        
        # Create enhanced evaluation context with GES and AD data
        eval_context = {
            # Include existing claims
            **existing_claims,
            # Include user context (AD groups)
            **user_context,
            # GES-specific data
            "ges_roles": existing_claims.get("ges_roles", []),
            "ges_groups": existing_claims.get("ges_groups", []),
            "ad_groups": user_context.get("groups", []),
            "ad_roles": user_context.get("roles", []),
            # Helper functions
            "now": now,
            "hours": hours,
            "days": days,
            "min": min_val,
            "max": max_val,
            "in": is_in,
            "has_any_role": has_any_role,
            "has_all_roles": has_all_roles,
            # Constants
            "api_key": api_key,
            "api_key_id": api_key_id,
            "true": True,
            "false": False,
            "null": None
        }
        
        # Process each formula
        for claim_name, formula in formulas.items():
            try:
                # Enhanced formula evaluation with GES and AD support
                
                # 1. Handle role-based checks with GES
                if "has_any_role" in formula and "ges_roles" in formula:
                    # Extract roles from formula like: has_any_role(['admin', 'user'], ges_roles)
                    if "has_any_role([" in formula and "], ges_roles)" in formula:
                        roles_part = formula.split("has_any_role([")[1].split("], ges_roles)")[0]
                        roles_to_check = [role.strip().strip("'\"") for role in roles_part.split(",")]
                        result[claim_name] = has_any_role(roles_to_check, eval_context["ges_roles"])
                    
                # 2. Handle role-based checks with AD
                elif "has_any_role" in formula and "ad_roles" in formula:
                    if "has_any_role([" in formula and "], ad_roles)" in formula:
                        roles_part = formula.split("has_any_role([")[1].split("], ad_roles)")[0]
                        roles_to_check = [role.strip().strip("'\"") for role in roles_part.split(",")]
                        result[claim_name] = has_any_role(roles_to_check, eval_context["ad_roles"])
                
                # 3. Handle group-based checks with AD
                elif "has_any_role" in formula and "ad_groups" in formula:
                    if "has_any_role([" in formula and "], ad_groups)" in formula:
                        groups_part = formula.split("has_any_role([")[1].split("], ad_groups)")[0]
                        groups_to_check = [group.strip().strip("'\"") for group in groups_part.split(",")]
                        result[claim_name] = has_any_role(groups_to_check, eval_context["ad_groups"])
                
                # 4. Evaluate basic comparisons
                elif " == " in formula:
                    left, right = formula.split(" == ", 1)
                    left_val = eval_context.get(left.strip(), left.strip())
                    right_val = eval_context.get(right.strip(), right.strip())
                    
                    # Handle string literals
                    if isinstance(right_val, str) and right_val.startswith("'") and right_val.endswith("'"):
                        right_val = right_val[1:-1]
                    if isinstance(left_val, str) and left_val.startswith("'") and left_val.endswith("'"):
                        left_val = left_val[1:-1]
                        
                    result[claim_name] = (left_val == right_val)
                    
                # 5. Handle ternary operations (x ? y : z)
                elif " ? " in formula and " : " in formula:
                    condition, rest = formula.split(" ? ", 1)
                    true_val, false_val = rest.split(" : ", 1)
                    
                    # Evaluate condition
                    condition_val = eval_context.get(condition.strip(), condition.strip())
                    if condition_val in ("true", True):
                        result[claim_name] = eval_context.get(true_val.strip(), true_val.strip())
                    else:
                        result[claim_name] = eval_context.get(false_val.strip(), false_val.strip())
                
                # 6. Handle basic math operations
                elif "+" in formula or "-" in formula or "*" in formula or "/" in formula:
                    # Very simplified - in a real implementation, use a proper expression parser
                    if "+" in formula:
                        left, right = formula.split("+", 1)
                        left_val = float(eval_context.get(left.strip(), left.strip()))
                        right_val = float(eval_context.get(right.strip(), right.strip()))
                        result[claim_name] = left_val + right_val
                    elif "-" in formula:
                        left, right = formula.split("-", 1)
                        left_val = float(eval_context.get(left.strip(), left.strip()))
                        right_val = float(eval_context.get(right.strip(), right.strip()))
                        result[claim_name] = left_val - right_val
                    elif "*" in formula:
                        left, right = formula.split("*", 1)
                        left_val = float(eval_context.get(left.strip(), left.strip()))
                        right_val = float(eval_context.get(right.strip(), right.strip()))
                        result[claim_name] = left_val * right_val
                    elif "/" in formula:
                        left, right = formula.split("/", 1)
                        left_val = float(eval_context.get(left.strip(), left.strip()))
                        right_val = float(eval_context.get(right.strip(), right.strip()))
                        if right_val != 0:
                            result[claim_name] = left_val / right_val
                        else:
                            result[claim_name] = 0
                
                # 7. Handle function calls
                elif "(" in formula and ")" in formula and formula.split("(")[0].strip() in eval_context:
                    func_name = formula.split("(")[0].strip()
                    if func_name in eval_context and callable(eval_context[func_name]):
                        # Extract argument
                        arg_part = formula.split("(", 1)[1].rsplit(")", 1)[0]
                        
                        # Very simplified argument parsing (just one argument supported)
                        if arg_part in eval_context:
                            arg = eval_context[arg_part]
                        else:
                            # Try to convert to appropriate type
                            if arg_part.isdigit():
                                arg = int(arg_part)
                            elif arg_part.replace('.', '').isdigit() and arg_part.count('.') <= 1:
                                arg = float(arg_part)
                            else:
                                arg = arg_part
                        
                        # Call the function
                        result[claim_name] = eval_context[func_name](arg)
                
                # 8. Direct variable lookup
                elif formula.strip() in eval_context:
                    result[claim_name] = eval_context[formula.strip()]
                    
                # Otherwise keep as string
                else:
                    result[claim_name] = formula
                    
            except Exception as e:
                logger.error(f"Error evaluating formula for claim '{claim_name}': {str(e)}")
        
        return result
    except Exception as e:
        logger.error(f"Error processing formula claims: {str(e)}")
        return {}

# Helper functions for external use
def get_ges_user_claims(username: str, api_key: str = None) -> Dict[str, Any]:
    """
    Helper function to get GES claims for a user using namespace from API key
    """
    try:
        if not api_key:
            # Use default namespace if no API key provided
            return ges_claims_service.get_user_claims(username)
        
        # Get namespace from API key configuration
        api_keys_dir = os.getenv("API_KEYS_DIR", "config/api_keys")
        api_key_file = os.path.join(api_keys_dir, f"{api_key}.yaml")
        
        if not os.path.exists(api_key_file):
            logger.warning(f"API key file not found: {api_key_file}")
            return {}
        
        with open(api_key_file, 'r') as f:
            key_data = yaml.safe_load(f)
        
        metadata = key_data.get('metadata', {})
        ges_config = metadata.get('ges', {})
        namespace = ges_config.get('namespace') or os.getenv("GES_DEFAULT_NAMESPACE", "default")
        
        return ges_claims_service.get_user_claims(username, namespace)
        
    except Exception as e:
        logger.error(f"Error getting GES claims for user {username} with API key {api_key}: {str(e)}")
        return {}

def validate_ges_access(username: str, api_key: str, required_role: str = None, 
                       required_group: str = None) -> Dict[str, Any]:
    """
    Validate if user has specific role or group in GES using namespace from API key
    """
    claims = get_ges_user_claims(username, api_key)
    
    validation_result = {
        "has_access": False,
        "user_claims": claims,
        "required_role": required_role,
        "required_group": required_group,
        "api_key_used": api_key
    }
    
    if required_role:
        user_roles = claims.get("ges_roles", [])
        validation_result["has_access"] = required_role.lower() in [r.lower() for r in user_roles]
        validation_result["reason"] = f"Role '{required_role}' {'found' if validation_result['has_access'] else 'not found'}"
    
    elif required_group:
        user_groups = claims.get("ges_groups", [])
        validation_result["has_access"] = required_group.lower() in [g.lower() for g in user_groups]
        validation_result["reason"] = f"Group '{required_group}' {'found' if validation_result['has_access'] else 'not found'}"
    
    return validation_result
