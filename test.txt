def get_metadata_filters(user_groups, classification, **kwargs):
    logger.info(f"user_groups received: {user_groups}")
    logger.info(f"Evaluating classification rules: {classification}")

    classification_values = []

    for group in user_groups:
        cn = extract_cn(group)
        for rule in classification:
            match_type = rule.get("match_type")

            if match_type == "startswith":
                prefix = rule.get("group_prefix")
                if prefix and cn.startswith(prefix):
                    logger.info(f"CN '{cn}' matches prefix '{prefix}'")
                    classification_values.extend(rule.get("value", []))

            elif match_type == "exact":
                name = rule.get("group_name")
                if name and cn == name:
                    logger.info(f"CN '{cn}' matches exact group name '{name}'")
                    classification_values.extend(rule.get("value", []))

    if classification_values:
        # Remove duplicates and build list of {"classification": value}
        metadata_list = [{"classification": val} for val in sorted(set(classification_values))]
        return {"metadata": metadata_list}

    return None


=============

dynamic_metadata:
  type: function
  module: claims.group_category
  function: get_metadata_filters
  args:
    user_groups: "[groups]"
    metadata_filters:
      - match_type: "startswith"
        group_prefix: "adspsa_"
        value:
          - proprietary
          - confidential
      - match_type: "exact"
        group_name: "alngc_maltas_maltatat_tp_busp"
        value:
          - confidential

      - match_type: "exact"
        group_name: "alngc_maltas_maltatat_tp_busp"
        value:
          - confidential
