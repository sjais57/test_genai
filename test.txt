def get_metadata_filters(user_groups, classification, **kwargs):
    logger.info(f"user_groups received: {user_groups}")
    logger.info(f"Evaluating classification rules: {classification}")

    classification_values = []

    for group in user_groups:
        cn = extract_cn(group)
        for rule in classification:
            match_type = rule.get("match_type")

            if match_type == "startswith":
                prefix = rule.get("group_prefix")
                if prefix and cn.startswith(prefix):
                    logger.info(f"CN '{cn}' matches prefix '{prefix}'")
                    classification_values.extend(rule.get("value", []))

            elif match_type == "exact":
                name = rule.get("group_name")
                if name and cn == name:
                    logger.info(f"CN '{cn}' matches exact group name '{name}'")
                    classification_values.extend(rule.get("value", []))

    if classification_values:
        # Remove duplicates and build list of {"classification": value}
        metadata_list = [{"classification": val} for val in sorted(set(classification_values))]
        return {"metadata": metadata_list}

    return None


============

def get_metadata_filters(user_groups, classification, **kwargs):
    """
    Returns metadata with classification values as a comma-separated string.
    
    Args:
        user_groups: List of user's group DNs (e.g., ["cn=dspsa_team,ou=groups"])
        classification: List of classification rules from YAML config
        
    Returns:
        {
            "metadata": {
                "classification": "proprietary, confidential"  # Single comma-separated string
            }
        }
        or None if no matches
    """
    for group in user_groups:
        # Extract common name (cn) from group DN
        cn = group.split(',')[0].split('=')[1] if '=' in group else group
        
        for rule in classification:
            # Check startswith rule (for dspsa_ groups)
            if rule.get('match_type') == 'startswith':
                prefix = rule.get('group_prefix')
                if prefix and cn.startswith(prefix):
                    values = rule.get('value', [])
                    if values:
                        return {
                            "metadata": {
                                "classification": ", ".join(values)
                            }
                        }
            
            # Check exact match rule (for specific groups)
            elif rule.get('match_type') == 'exact':
                group_name = rule.get('group_name')
                if group_name and cn == group_name:
                    values = rule.get('value', [])
                    if values:
                        return {
                            "metadata": {
                                "classification": ", ".join(values)
                            }
                        }
    
    return None
=============

dynamic_metadata:
  type: function
  module: claims.group_category
  function: get_metadata_filters
  args:
    user_groups: "[groups]"
    metadata_filters:
      - match_type: "startswith"
        group_prefix: "adspsa_"
        value:
          - proprietary
          - confidential
      - match_type: "exact"
        group_name: "alngc_maltas_maltatat_tp_busp"
        value:
          - confidential

      - match_type: "exact"
        group_name: "alngc_maltas_maltatat_tp_busp"
        value:
          - confidential
