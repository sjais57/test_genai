def get_metadata_filters(user_groups, classification, **kwargs):
    logger.info(f"user_groups received: {user_groups}")
    logger.info(f"Evaluating classification rules: {classification}")

    classification_values = []

    for group in user_groups:
        cn = extract_cn(group)
        for rule in classification:
            match_type = rule.get("match_type")

            if match_type == "startswith":
                prefix = rule.get("group_prefix")
                if prefix and cn.startswith(prefix):
                    logger.info(f"CN '{cn}' matches prefix '{prefix}'")
                    classification_values.extend(rule.get("value", []))

            elif match_type == "exact":
                name = rule.get("group_name")
                if name and cn == name:
                    logger.info(f"CN '{cn}' matches exact group name '{name}'")
                    classification_values.extend(rule.get("value", []))

    if classification_values:
        # Deduplicate and sort for consistency (optional)
        unique_values = sorted(set(classification_values))
        metadata_output = [{"classification": unique_values}]
        logger.info(f"Returning metadata: {metadata_output}")
        return {"metadata": metadata_output}

    logger.info("No matching group found for classification rules. Returning None.")
    return None










import logging
from typing import List, Dict, Any

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def get_user_category(user_groups: List[str], lookup_mode: str = 'FIRST_MATCH', **kwargs) -> Dict[str, Any]:
    """
    Assign user to a category based on group membership and lookup mode.
    
    Args:
        user_groups: List of groups the user belongs to
        lookup_mode: 'FIRST_MATCH', 'ALL_MATCHES', or 'TIERED_MATCH'
        metadata: (kwarg) metadata dictionary containing 'categories'
    Returns:
        Dict with category assignment result including all category data from metadata
    """
    logger.info(f"Assigning user category for groups: {user_groups} with mode: {lookup_mode}")
    
    # Get metadata from kwargs
    metadata = kwargs.get('metadata', {})
    logger.info(f"Metadata received: {metadata}")
    
    if not metadata:
        logger.warning("No metadata provided")
        return {"category": None, "match_mode": lookup_mode, "reason": "No metadata provided"}
    
    categories = metadata.get('categories', {})
    if not categories:
        logger.warning("No categories found in metadata")
        return {"category": None, "match_mode": lookup_mode, "reason": "No categories in metadata"}

    matches = []
    for cat_name, cat_data in categories.items():
        cat_groups = cat_data.get('groups', [])
        # If any group matches, consider this category
        if any(g in user_groups for g in cat_groups):
            # Include all category data from metadata
            full_category = {
                "name": cat_name,
                **cat_data  # Include all properties from the category definition
            }
            matches.append(full_category)

    if lookup_mode == 'FIRST_MATCH':
        if matches:
            return {"category": matches[0], "match_mode": lookup_mode}
        else:
            return {"category": None, "match_mode": lookup_mode, "reason": "No match"}
    elif lookup_mode == 'ALL_MATCHES':
        return {"categories": matches, "match_mode": lookup_mode}
    elif lookup_mode == 'TIERED_MATCH':
        # Assume each category has a 'tier' field for ranking (higher is better)
        if matches:
            best = max(matches, key=lambda x: x.get('tier', 0))
            return {
                "category": best,
                "match_mode": lookup_mode,
                "destURL": best.get('destURL'),  # Include destination URL
                "tier": best.get('tier')          # Include tier information
            }
        else:
            return {"category": None, "match_mode": lookup_mode, "reason": "No match"}
    else:
        logger.warning(f"Unknown lookup_mode: {lookup_mode}")
        return {"category": None, "match_mode": lookup_mode, "reason": "Unknown lookup_mode"}



============================

import logging
from typing import List, Dict, Any, Optional

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def get_user_category(
    user_groups: Optional[List[str]], 
    lookup_mode: str = 'FIRST_MATCH', 
    **kwargs
) -> Dict[str, Any]:
    """
    Assign user to a category based on group membership and lookup mode.

    Args:
        user_groups: List of groups the user belongs to.
        lookup_mode: 'FIRST_MATCH', 'ALL_MATCHES', or 'TIERED_MATCH'.
        metadata: (kwarg) metadata dictionary containing 'categories'.

    Returns:
        For FIRST_MATCH: {'category': <category_dict or None>, ...}
        For ALL_MATCHES: {'categories': [<category_dict>], ...}
        For TIERED_MATCH: {'category': <highest_tier_category or None>, ...}
    """
    logger.info(f"Assigning user category for groups: {user_groups} with mode: {lookup_mode}")
    metadata = kwargs.get('metadata', {})
    if not metadata:
        logger.warning("No metadata provided")
        return {"category": None, "match_mode": lookup_mode, "reason": "No metadata provided"}

    categories = metadata.get('categories', {})
    if not categories:
        logger.warning("No categories found in metadata")
        return {"category": None, "match_mode": lookup_mode, "reason": "No categories in metadata"}

    user_groups = user_groups or []  # handle None

    matches = [
        {"name": cat_name, **cat_data}
        for cat_name, cat_data in categories.items()
        if any(g in user_groups for g in cat_data.get('groups', []))
    ]

    if lookup_mode == 'FIRST_MATCH':
        match = matches[0] if matches else None
        logger.info(f"FIRST_MATCH assigned: {match}")
        return {"category": match, "match_mode": lookup_mode, "reason": None if match else "No match"}
    
    if lookup_mode == 'ALL_MATCHES':
        logger.info(f"ALL_MATCHES found: {matches}")
        return {"categories": matches, "match_mode": lookup_mode, "reason": None if matches else "No match"}
    
    if lookup_mode == 'TIERED_MATCH':
        match = max(matches, key=lambda x: x.get('tier', 0)) if matches else None
        logger.info(f"TIERED_MATCH assigned: {match}")
        return {"category": match, "match_mode": lookup_mode, "reason": None if match else "No match"}

    logger.warning(f"Unknown lookup_mode: {lookup_mode}")
    return {"category": None, "match_mode": lookup_mode, "reason": "Unknown lookup_mode"}

